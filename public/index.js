"use strict";

const submitBtn = document.getElementById("submit");
const promptInput = document.getElementById("prompt");
const responseBlock = document.getElementById("responseBlock");
const responseEl = document.getElementById("response");
const stepsList = document.getElementById("stepsProgressList");
const promptBlock = document.querySelector(".promptBlock");
const container = document.getElementById("container-2");

function clearPreviousStatus() {
  const oldBtn = document.querySelector('.download-button');
  if (oldBtn) oldBtn.remove();
  responseEl.innerHTML = "";
  stepsList.innerHTML = "";
}

function setGeneratingState(isGenerating) {
  if (isGenerating) {
    submitBtn.classList.add("disabled");
    promptBlock.classList.add("faded");
    responseBlock.classList.remove("expanded");
    responseBlock.classList.add("collapsed");
    container.classList.remove("end")
  } else {
    submitBtn.classList.remove("disabled");
    promptBlock.classList.remove("faded");
    responseBlock.classList.remove("collapsed");
    responseBlock.classList.add("expanded");
    container.classList.add("end")
  }
}

function renderMarkdownSteps(length, data) {
  return new Promise((resolve) => {
    stepsList.innerHTML = "";
    const allSteps = [];

    for (let i = 0; i < length; i++) {
      const markdown = data.past_steps[0][i];
      const html = marked.parse(markdown);
      const doc = new DOMParser().parseFromString(html, "text/html");
      Array.from(doc.querySelectorAll("h3")).forEach(h3 =>
        allSteps.push(h3.textContent)
      );
    }

    if (!allSteps.length) return resolve();

    allSteps.forEach((stepTitle, i) => {
      setTimeout(() => {
        const li = document.createElement("li");
        li.className = "step-progress";
        li.textContent = stepTitle;
        stepsList.appendChild(li);
        if (i === allSteps.length - 1) {
          setTimeout(resolve, 600);
        }
      }, i * 600);
    });
  });
}

// Convert markdown into docx paragraphs
function markdownToDocxParagraphs(markdown) {
  const { Paragraph, TextRun, ExternalHyperlink, HeadingLevel } = window.docx;
  const lines = markdown.split('\n');
  const paragraphs = [];

  for (let line of lines) {
    line = line.trim();
    if (!line) continue;

    const headingMatch = /^(#{1,4})\s+(.*)/.exec(line);
    if (headingMatch) {
      paragraphs.push(new Paragraph({
        text: headingMatch[2],
        heading: HeadingLevel[`HEADING_${headingMatch[1].length}`],
        spacing: { after: 100 }
      }));
      continue;
    }

    const regex = /(\[([^\]]+)\]\(([^)]+)\))|(\*\*([^*]+)\*\*)|(\*([^*]+)\*)|(`([^`]+)`)/g;
    const runs = [];
    let lastIndex = 0;
    let match;

    while ((match = regex.exec(line)) !== null) {
      if (match.index > lastIndex) {
        runs.push(new TextRun(line.slice(lastIndex, match.index)));
      }
      if (match[1]) {
        runs.push(new ExternalHyperlink({ link: match[3], children: [new TextRun({ text: match[2], style: "Hyperlink" })] }));
      } else if (match[4]) {
        runs.push(new TextRun({ text: match[5], bold: true }));
      } else if (match[6]) {
        runs.push(new TextRun({ text: match[7], italics: true }));
      } else if (match[8]) {
        runs.push(new TextRun({ text: match[9], font: "Courier New", size: 20 }));
      }
      lastIndex = regex.lastIndex;
    }

    if (lastIndex < line.length) {
      runs.push(new TextRun(line.slice(lastIndex)));
    }

    paragraphs.push(new Paragraph({ children: runs, spacing: { after: 200 } }));
  }

  return paragraphs;
}

// Generate .docx and trigger download
async function generateDocx(prompt, markdown) {
  const { Document, Packer, Paragraph, HeadingLevel } = window.docx;
  const doc = new Document({
    creator: "deepQuest",
    title: "Research Report",
    description: "Generated by deepQuest AI",
    styles: {
        default: {
        document: {
            run: {
            font: "Arial",
            },
            paragraph: {
            spacing: { after: 200 },
            },
        },
        },
    },
    sections: [{
      children: [
        new Paragraph({
          text: "Research Report: " + prompt,
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        ...markdownToDocxParagraphs(markdown)
      ]
    }]
  });

  const blob = await Packer.toBlob(doc);
  saveAs(blob, "deepQuest_Report.docx");
}


submitBtn.addEventListener("click", async function(e) {
    e.preventDefault(); 
    console.log("Button clicked!");

    clearPreviousStatus();
    setGeneratingState(true);

    const spinner = document.createElement('dotlottie-player');
    spinner.setAttribute('src', 'https://lottie.host/c669f4d8-e435-4fa0-8ed6-520e2f062856/HQNOJK9lDy.lottie');
    spinner.setAttribute('autoplay', '');
    spinner.setAttribute('loop', '');
    spinner.setAttribute('speed', '1');
    spinner.setAttribute('background', 'transparent');
    spinner.className = 'lottie-spinner';
    responseBlock.appendChild(spinner);

    const msg = document.createElement('p');
    msg.className = "progress-message";
    msg.innerHTML = "Generating Report....";
    responseBlock.appendChild(msg);

    container.classList.add("start");
    promptBlock.classList.add("reposition");
    responseBlock.setAttribute("aria-busy", "true");

    const prompt = promptInput.value.trim();
    promptInput.value = "";
    try {
        const response = await fetch("/api/research", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ topic: prompt })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log(data);

        const spinner = document.querySelector("dotlottie-player");
        if (spinner) spinner.remove();

        const progMsg = document.querySelector(".progress-message");
        if (progMsg) progMsg.remove();

        setGeneratingState(false);
        await renderMarkdownSteps(data.past_steps[0].length, data);

        setTimeout(async () => {
            const markdown = data.response;
            const html = DOMPurify.sanitize(marked.parse(markdown));

            responseEl.innerHTML = html;
            responseEl.focus(); // Keyboard & screen reader users jump here
responseBlock.removeAttribute("aria-busy");

            
            const downloadButton = document.createElement("button");
            downloadButton.className = "download-button";
            downloadButton.innerHTML = 'Download Report <i id="download-icon" data-lucide="download"></i>';
            responseBlock.appendChild(downloadButton);
            
            downloadButton.addEventListener("click", async () => generateDocx(prompt, data.response));
            
            void responseBlock.offsetHeight;

            setTimeout(() => {
                const anchors = responseEl.querySelectorAll("#response a");
                anchors.forEach(anchor => {
                    console.log("Anchor found:", anchor);
                    const icon = document.createElement("i");
                    icon.setAttribute("data-lucide", "link");
                    icon.className = "link-icon";
                    anchor.insertAdjacentElement("afterend", icon);

                });
                lucide.createIcons();
            }, 0);
        }, 600);

    } catch (error) {
        console.error("Fetch error:", error);
    }
});

promptInput.addEventListener("keydown", function(event) {
    if (event.key === "Enter") {
        event.preventDefault(); 
        submitBtn.click(); 
    }
});

window.onload = () => {
    lucide.createIcons();
}